Async Patterns in Node.js

by Brice Wilson

Node.js is built from the ground up to support asynchronous coding patterns. This course will teach you multiple techniques for writing modern, asynchronous JavaScript that helps you deliver fast and responsive Node applications.
Start Course
Download Course
Schedule Reminder

Course Overview

[Autogenerated] Hey, everybody. My name is Bryce Wilson, and welcome to my course a sync patterns in Node.js I'm a server and client side web developer. Note is an increasingly popular choice for developers that want to build fast, responsive server applications. The single threaded nature of the node event Luke makes writing asynchronous code an essential skill for every no developer. The techniques for writing a synchronous code in JavaScript have evolved over the years, and I'll show you some classic syntax as well as all of the most modern approaches. Some of the major topics that will cover include using callback functions, promises and the A sync and await keywords, creating and responding to events with event emitters and taking advantage of worker threads. By the end of the course, you'll have a solid understanding of asynchronous programming patterns and node and when to use different techniques in your own projects. Before beginning this course, you should be familiar with the basics of JavaScript, but you certainly don't need to be an expert. I hope you'll join me on this journey to learn asynchronous programming with E. A sync patterns in Node.js course at Pluralsight Yeah,
The Event Loop and the Need for Asynchronous Code
The Need for Asynchronous Code

[Autogenerated] Hey, everybody, I'm Bryce Wilson. Welcome to my course on a sync patterns in Node.js. I'm a big fan of note, and there is nothing quite so fundamental to know development as the use of asynchronous code except maybe JavaScript itself. You can often build perfectly good apps in C#, Java, iPad, python and other languages with no real knowledge of how to execute a synchronously. That's not really the case with JavaScript. Is it possible to build a No doubt that only contains synchronous code? Technically, sure it is. However, you'll likely run into performance problems very quickly and your ability to learn from others, use popular libraries and read and understand technical documentation will all be greatly limited. Asynchronous code is so essential to JavaScript and nodemon that not understanding how it works and using it in your apps kind of feels like you're doing it wrong. In software development, we've all heard someone asked if they should use this technique or that technique and heard the standard answer of Well, it depends if someone asked if they should use a synchronous code in their node apps. There are no qualifications. The answer is yes. In this course I'm going to show you several different techniques for writing asynchronous code in your node apps. But we're also going to go a little beyond just the JavaScript syntax and look at how to use nodes event emitter class to write event driven code. And we'll also look at a relatively new feature in node, known as web workers. That lets us right code that truly executes in parallel to appreciate what a neat trick that is. You need to fully understand how the JavaScript event loop works. The event loop is really at the heart of everything we're going to do in this course, So let's now take a few minutes to understand what it is and how it works.
Understanding the Event Loop

[Autogenerated] JavaScript is single threaded, so it can only executable code at a time. I'm going to refer to those chunks of code. Here is task, but sent tactically, a task is usually a JavaScript function. The event loops synchronously executes task in the synchronous task UI. This is effectively the call stack for your application, your program starts to execute and, as one function calls, another tasker added to the Q and the JavaScript runtime will execute them synchronously until there are no more task in the queue. However, since only one thing connects acute at a time, relatively long running tasks like disc iOS or network calls will block any other code from executing. If you run them synchronously, the note runtime and Web browsers, for that matter, minimize this blocking by allowing us to execute POCO code A synchronously. The runtime includes a set of APIs for common long running task and will execute them for us and notify us when they're done. By adding task to an asynchronous task UI, these asynchronous task or callback functions they exist to call back into our single threat of execution and run some code that we write to process the results of the API call when the event loop has processed all the items in the synchronous task you it will look for task in the asynchronous task UI. If it finds one, it will run it and then look to see if there any more waiting to execute. In addition to the a sync task you there is also something known as the micro task UI asynchronous task added to it will be prioritized higher than task in the regular a sync task you So when the event loop is done with all the synchronous work, if there are task waiting in the micro task you, they'll be executed ahead of any task waiting in the regular a sync task UI. It's possible to add items directly to the micro task you, but probably the most common way task it added to it is with the resolution of promises which will look at in the next module. At this point, you may be wondering if JavaScript is single threaded where these asynchronous task running while the event loop executes other parts of my application code. Well, the only part of all this that's limited to a single thread is your JavaScript code when you use nodemon modules like F s to access the file system or the Net module to make network calls, you're actually calling into code written in C++ that can and does use multiple threads to perform that work. Those modules will add your callback functions to the A sync cues I showed you on the last slide. So the goal is to all float as much of the I O and other long running task is possible, leaving our single threaded event loop free to handle new requests from our users. Let's nail start looking at some code and the techniques available for us to do that.
Demo Project Overview

[Autogenerated] before we start writing some new code, I want to show you the demo app will be working with and how the project is structured. You've probably seen this website for carved rock fitness in other Pluralsight courses. Carved Rock is a fictional company that sells outdoor clothing and equipment. We're going to imagine in this course that we've been working on this prototype for their website redesign. The user interface is mostly done and looks really nice, but it's our job to start converting the proof of concept server code into something more performance and ready for a production environment. Right now, only the clothing link here at the top of the page actually returns data from our nodes server app. Before I click on it, I'm going to open the browser developer tools so we can see the request that is generated. With that open, I'll click on clothing. You can see I get a few items here on the page. I'll scroll up just a bit in the developer tools, and you can see the link here for the API request that was sent to the server. I'll hover over it and you can see that the full U R l is local host port 3000 slash API slash clothing. I'll click on it and we can now see the JSON data that was returned. Each item has an ID, a name and a price with some simple formatting. The same data is shown on the page here. You can see that Climbing shoes error $59 and down in the developer tools I can, expand the third element and you can see the raw data. Let's now go have a look at the project and the actual code that's returning this data. I'm going to use visual studio code in this course, but feel free to use your favorite editor. The first file I want to show you is the package that JSON file here in the root of the project. You can see I'm not using very many packages right now. I've only got five items in the dependency section and they're all pretty standard for a no doubt. The one I really want to point out is express. I've added the express framework to help me build the API for the app. The one Dev dependency I have is nodemon. If you're not familiar with nodemon. It's just a little program that runs your node app and then watches for changes to any of the code files. If it sees a change to a file, it will automatically restart the server. This is nice because it saves you the trouble of constantly stopping and restarting your server after every little change while you're working. I've got one npm script named Start that uses nodemon to execute these. Server dot Js file. Let's take a look at how this works in the visual studio terminal. You can see that my server is already running on Port 3000. I'll press control C to stop that for just a minute. Okay, if you want to run the app like I'm about to, you can download all of the code from the course page on Pluralsight dot com. Or you can get it from my GitHub account at the link here on the screen. The GitHub repo is also a good place for me to post small updates and bug fixes between updates of the course. However, you choose to get the code before you run it, you'll need to install all of the npm packages you can do that by running the command npm install inside a terminal in the main project directory that will install nodemon and the other packages you saw in my package JSON file. I'm not going to run it now, since I've already got all the packages installed. Instead, I'll restart the server with the command npm start. You can see that executed the command nodemon space server dot Js, which ultimately started my server running on Port 3000. You can also see that nodemon is watching for changes to files in my project directory. Okay, now that the servers running again, let's have a look at the other files in the project. The dot V s code folder just contains some settings for my editor. The disc folder contains all the static assets for the site the HTML file CSS files and things like that. We won't be doing much with all of this. Below that is the nodemon, a jewels folder where the npm packages error installed. Before I show you the server folder, I'm first going to open the server dot Js file in the root of the project. I've tried to keep this relatively short and simple. This is the file that will run to start the server. I'm not going to go over every line here, but I will quickly point out that I'm requiring express using it to create a nap and then configuring it to run on Port 3000 online. Six. You can see that I'm requiring a file named Clothing inside the server slash Routes directory, and we'll look at it in just a minute. Online 16 I can figure the app to use the code in the clothing file whenever a request is made to slash API slash clothing. Toward the end of the file, I start the app listening on the configured port and just log a message to the console with that information. Let's now look inside the server folder. We're all right. Most of our code inside the data folder is a single file named clothing dot JSON. It just contains the clothing data that gets returned to the browser rather than complicating the application with the database you have to install and configure. I'm just storing the data and adjacent file. Our server code will read and updated as requested by the client. Inside the routes folder. I'll open the clothing dot Js file. This is the file I required in server dot Js and will handle all requests to slash API slash clothing. Right now, it's only program to handle get request. The slash here refers to the root of the route configured for this code, which is API slash clothing. When I get request comes into that you are real. The code inside this callback function will execute the request parameter will contain data about the HTTP request and I'll use this response parameter to send data back to the client. Currently, the code uses the Node.js module to read the data from the clothing dot JSON file. The data from that file is then parsed is JSON and returned to the browser, bypassing it to the Sindh method. On the response object notice that the method I'm currently using to retrieve the data is named read file sync. As the name suggests, that method will execute synchronously and will block the event Luke preventing any other code from executing while the file is red. This is obviously not how we want the production version of our new website to work. So in the next clip, I'll start converting this synchronous code to asynchronous code
Converting Synchronous Code to Asynchronous Code

[Autogenerated] Now that you've seen how the APP works, let's start turning the synchronous proof of concept code into a synchronous code more appropriate for a production environment. The call back pass to the get method is currently programmed to read the clothing dot JSON file synchronously using the read file sync method of the FS module. Before I convert this code to execute a synchronously, I want to add a couple of log statements so we can more clearly observe when particular lines error, executing just before the data is sent back to the browser. A log that I'm returning clothing data right after the data is sent, a log that the app is now doing more work. I'll quickly glance at my terminal in ves code, and you can see that nodemon recognize the change to the code and automatically restarted my server on Port 3000. I'll kneel, hop back over to my browser and refresh the page that caused the get method and displays the clothing data. Since I added the log statements to my server side code, I'll now go back to V s code and look at the output in my terminal you can see here that the code basically executed in the order it was written. We first got the message that the clothing data was being returned, and then the message that the app is doing more work. Let's now rewrite this code to execute a synchronously. The simplest way to do that is to use a different method in the FS module that's designed to read files a synchronously. I'm first going to remove all with the last log statement here. I'll then call the read file Method on the FS module. Notice that the first two parameters to read file are exactly the same as the first two parameters I passed to read File sync, the variable containing the path of the file and the file encoding to use. However, I'm also passing an arrow function as the third parameter here. This function will be called after the contents of the file have been read while the file is being read. The rest of the code inside the get method will continue to execute. This function is a callback function and is the most basic way to handle the completion of an asynchronous task. Technically, a callback function is no different than any other function. However, when using callbacks with asynchronous code and nodemon error is a very well established convention of passing two parameters to the callback. The first is any error that occurred while the asynchronous code was executing. And the second is any data. The code returned. You will see this pattern all over the place in node apps. So for your own sanity and the sanity of your fellow developers, I strongly suggest you follow it yourself. It's also a convention to name these parameters error, er e r r and data. As I've done here inside the callback, the first thing you want to do is use an if statement to see if an actual error was passed in. If so, you can handle it. However you like. I'm just going to log it here. If there was no error, then no will be passed for that parameter and the code in the else block and process the data returned. I'm going to add nearly identical code here, too, that I was using when the data was returned synchronously, I'll parse it, logged that I'm returning it to the client and then send it to the browser I'll nail, hop back over to my browser and refresh the page again. The data still gets returned. However, back in my terminal, you can see that the log statements executed in a different order. This time we first see that the code is doing more work, and sometime later we got the message that the app was returning clothing data because I changed the code to use these asynchronous read file method. The event loop wasn't blocked, and the code and the get method continued to executable. The contents of the file were red. This is a much better solution. However, there are still improvements we can make. Let's do that next.
Accepting Callbacks as Parameters

[Autogenerated] In the last clip, I wrote some asynchronous code by calling AD FS method that was passed a call back as a parameter. In this clip, I'll re factor that and write my own, a sync method that accepts a callback. The code IT wrote in The last clip works fine, and there's nothing terribly wrong with it. However, I think with a little re factoring, it could be better. What I want to do is extract the code that reads the data file out into its own function. I can call from other places. The first thing I'll do is stub out a new function named Get Clothing Data. I'll then copy everything with the last log statement from the get function and pasted inside the new function. I can't directly return the data to the client from here, so I'll remove this log statement. And instead of calling the sin method on the response object, I'll just use a return statement to pass the data back to the collar. I'll now at a call to the new function inside the get method above, I will sign the value it returns to a variable named clothing data. I'll then logged that I'm returning the clothing data to the client and then call the sin method again with the data. This looks pretty similar to what I had before, but I've just extracted the reading of the file into its own method. Let's see what happens when I run it. I'll go back to my browser and refresh the page. The page loads fine, but I no longer have any data being displayed back in my editor. I'll open the terminal and you can see that the log statements executed in the order they appear in the code. So what's going on here? Why didn't I get any data in the browser to understand what's happening? Let's look closely at the code and the get method First. There's really nothing asynchronous about this code. It's going to execute a PTA bottom. It calls. They get clothing, data function, and as soon as it returns, the first log statement will execute and the clothing data variable will be sent to the client. The problem is in the get clothing data function below. The first line of that function calls the asynchronous read file function. The rest of the code here is all part of the callback function passed to read file. It won't execute until the file is done being read from the disk. While that's happening, the rest of the get clothing data function continues to execute. However, there's no more code in the function, so it effectively just ends and returns undefined to it's collar. That means the clothing date of variable is assigned undefined, which is ultimately what gets sent to the client online. 13. The solution to this problem is, instead of trying to use a return statement to pass the data back to the caller, we need to pass our own callback function to get clothing data that can notify the collar when the data is actually ready. I need to pass that call back as a parameter to get clothing data. I'm going to pass it as an arrow function. Remember the Convention for nodemon callbacks I mentioned earlier? They should take two parameters. The first will be for any error that occurs, and the second is for any data being returned in the body of the call back. I'll first check to see if there was an error. If so, I'll just log it to the console. Otherwise, I want to take the data that was returned and send it back to the browser. I've already got a couple of lines of code that do that. So I'll copy and paste them inside this else block. I now I just need to change the variable I'm sending to the client from clothing data to just data. Okay, that's all I need to do here. But I now need to re factor get clothing data to accept this function as a parameter. I'll add a new parameter to the function declaration and just name it. Call back. I now need to call this function with the appropriate error and data values somewhere inside the body of get clothing data. I've already got an if block that checks for any error that occurred when reading the file. Instead of logging that error, I'll now call the callback function and passed the error that occurred as the first parameter and null as these second parameter. Since we know we don't have any data to return since the callback parameter stores a function I can call that function by just adding a pair of parentheses around the parameter names and pass it any values it needs. I'm going to do something similar inside the else blog. I'll overwrite the return statement with a call to the callback function. In this case, I don't have an error, so I'll pass No as the first parameter and the parsed clothing data as these second parameter, we now have in place the proper mechanism for notifying the collar that they get clothing. Data function is done doing its work. Since we're now communicating with a callback function and not a return statement I can remove the variable receiving a return value from get clothing data. Okay, let's give it a try. I'll go back to my browser and refresh the page again. The data reappears. This time I'll go back to V s code and check my terminal again. You can also see that the order of the log statements is back to what we want as well. It first logged that it was doing more work, which means the event loop was not blocked while the foul was being read from disk. After the foul was red, we see the log message that the data is being returned. The result is the same as the code in the last demo, but we've now re factored the reading of the file out into its own method that accepts a callback function. It makes that code more reusable and the caller of the new function can do pass in any callback they like. I've covered a few important topics in this module, but the number one thing I want you to take away from it is don't block the event loop. I showed you how the event Liu works at a high level and explained that the code you write runs in a single thread. Therefore, if you want to keep your apps responsive, you need to keep that event loop looping and picking up new code to execute. The best way to do that is to write a synchronous code. A sync code will keep your app responsive and is practically required when writing production quality note applications. The oldest and most fundamental way to write a synchronous code is with callback functions, and you've now seen how to use them to communicate the results of asynchronous work. However, callbacks aren't the only way to communicate those results in the next module. I'll show you how promises and the A sync and await keywords are a more modern approach to processing asynchronous results that also come with a few additional small benefits. So stay tuned for that.
Writing Asynchronous Code with Promises and async/await
Alternatives to Callbacks

[Autogenerated] in the last module, I showed you how to write and use callback functions. Callbacks have been around forever in JavaScript and are the most fundamental way to handle the results of asynchronous operations in this module. We're going to look at a couple of more modern techniques for writing, asynchronous code promises and a sync away well. First, take a look at promises. I think you'll quickly see that even though the syntax is a little different for promises there conceptually similar to callback functions, since you effectively registered different functions to process the results of your asynchronous operations. A discussion of promises often very naturally leads to a discussion of the even newer, a sync and awake keywords. But before I discuss those, we're going to take a brief detour and talk about a lesser known feature of modern JavaScript. No Nas generators. Even though you won't often use generators directly, they enable the functionality we get with the A sinking away keywords. So I think it's important to give you an overview of what they are and how they work. Well, then look at how to use a sync in a wait, and I'll show you how they're really built on top of promises and generators and let you write asynchronous code in a much more readable style. Let's get started with a look at promises.
Understanding Promises

[Autogenerated] The Mozilla Documentation defines a promise as an object representing the eventual completion or failure oven asynchronous operation code that performs asynchronous operations. Can do return a promise to the caller. The color com'on register functions that should execute the promises either resolved or rejected. Resolved is the term used to describe the successful completion of the asynchronous task and rejected is the term used to describe the state of a promise that reports an error in the asynchronous code. Promised libraries have been available in JavaScript for years, but the feature was finally made a native part of the language in the E S 2015 versioning. They include a basic API for attaching what error essentially callback functions to an object, and the methods on promise objects also returned promises so they can easily be chained together. I think most developers first encounter promises as the return type for some library function they're calling, but it's not terribly difficult to create your own, and I'll show you how to do that in the demo app in just a couple of minutes. Let's first look at the basic syntax for promises. I'll first show you how to create a promise and then we'll see how to process the resolution and rejection of one. To create a promise. You pass a function to the promised constructor. I'm first going to create a declaration just for that function. This is the function that will actually perform the asynchronous work. So I've named this one. Do a sync work. It will automatically be passed to functions as parameters. The first is the function to call if the asynchronous work complete successfully, and the second is the function to call. If you need to reject the promise with an error inside this function, I'm just going to add a bit of pseudo code you would normally perform. Sameh sync prints work, and if it's successful, you call the resolve function and pass it the data you want return to the color. If the work was not successful, you call reject and passed the reason for the rejection that could be an error object, a simple error message, string or whatever makes sense for your app. Do you actually create the promise you would pass this function to the promised constructor, which returns a new promise object? I've declared the function passed to the constructor separately here, but it's more common to just pass an arrow function to the promised constructor. Here I am still assigning the result of instantiate ing a new promise to a variable, but I'm passing an arrow function to the constructor instead. The arrow function takes the same resolve and reject parameters we saw a minute ago, and the body of the function looks just like the body of the earlier function. I call resolve if it's successful and reject. If it's not, let's now look at how to process the results from a promise. Let's imagine that I call a method that returns a promise object. I could capture the object in the variable and then call methods on it. But it's more common to just chain calls onto the method that returns the promise. You change on a call to a method named then to handle the successful resolution of the promise you pass the function, another function that will execute when the promises resolved. This function will be passed one parameter, that is, the data passed to the resolved method I showed you earlier. You can do with it whatever you like here. I'm just logging it to handle a rejected promise. You chain on a call to a method named Catch. That method also accepts a function as a parameter. In this case, the function passed to catch when we passed the reason for the rejection instead of the data that parameter is named error here and will contain the value pass to the reject function I showed you earlier. A third method you can chain onto the others is named finally. All of the methods error optional, and this one is certainly the least used of the three. The then method is only called it. The promises resolved catches only called if it's rejected, however, finally is called. In both cases, it's a good place to put any cleanup code or really anything that you always want to run. After the promise is done, let's now go back to the demo app and replace the callback code I wrote earlier with promises
Replacing Callbacks with Promises

[Autogenerated] I'll nail remove the earlier callback code. I added to the demo app and show you how to create and use promises for the same asynchronous work. Instead, the first example I want to show you is using a promise inside the get clothing data function. Instead of reporting the results to the caller with a callback function at the top of the function, I'll write the code to create and return a new promise all on one line. Remember that the Promise constructor takes a function as a parameter. I'm going to pass it a narrow function. This function takes two parameters, which are the resolve and reject functions. We need to call to either resolve or reject this promise and report the results to the caller. The asynchronous work I want to do really hasn't changed, so I'm going to copy and paste all of this existing code. Inside the function passed to the promised constructor, I only need to make a couple of small changes to it. Instead of calling the callback function. When there's an error, I'm going to call the reject function and pass it the reason for the error. I'm just going to pass it the entire error. If the follows red successfully, rather than passing the results to the call back, I'll call the resolve function and passed them to it instead. Since I'm no longer using the callback function I can delete it as a parameter to get clothing data. Okay, that's all I need to do to this function. To have it create and return a promise I now need to update the calling code to process the promise it returns. I'm first going to delete all the existing code inside the get method. Except for the last log statement, it's helpful for us to verify that the code above it isn't blocking the event loop. I'll now call get clothing data just like I would call any other function. I could capture the promise it returns in a variable. But as I showed you earlier, it's conventional to just chain on calls to the promise methods that will let you register the functions that will process the results. I'll first at a call to the then method. It takes a function as a parameter, and that function will be passed. Whatever was passed to the resolve method in the asynchronous code, in this case, that will be the clothing data. I'm just going to log a message to the console and then use the response object to send the data back to the browser to handle the rejection of the promise. I'll now chain on a call to the catch method. It's also passed a function the parameter to it will contain whatever was passed to the reject function in the asynchronous code. This obviously means something went wrong. So I'm going to use the response object to send an HTTP 500 status back to the browser, along with the error reported by the promise many times, these error the only two methods you'll use to process the results of a promise. However, you can also change on a call to the finally method. If you have some code you want to execute. In both the resolution and rejection cases, the function past to it takes no parameters, so I have to include an empty pair of parentheses in my arrow function. I'll keep the body simple and just log a message to the console. Everything should be in place. Now. I'll go back to my browser and refresh the page again, the functionality remained the same, and I still get all the clothing data on the screen back in ves code, I'll open the terminal. The order of the log messages confirms that the code is still executing a synchronously and not blocking the event loot. While the data file is red, the doing more work message still appears first, even though it's the last line of the get method. Once the data is done being read from the disk, we see the messages that it's being sent to the browser, followed by the message I added to the finally method. That was a good test of the successful reading of the file. However, I also want to test that when there's an error the promises rejected and reports the error back to the collar as it should. I'll force an error by changing the name of the data file. The code is looking for here. At the top of this file, I'll change clothing JSON too bad name dot JSON, which doesn't exist. I'll go back to the browser again before I refresh the page. This time, I'm going to open the browser developer tools to the network tab. Remember that in the case of a rejected promise, I'm attempting to return a 500 server error to the browser. I'll now refresh the page, and you can immediately see I no longer have any data on the screen. I'll scroll up just a bit in the list of network request, and here you can see the request for the data. And it did, in fact, return of 500 server error. Back in my editor, I'll open the terminal again just to show you that even though this promise was rejected, the code inside the finally method executed just as It did for the resolve promise. I still have the message in the console reporting that the processing is all done. I don't want to lead the error in the code, so I'll quickly change the name of the data file back to clothing JSON. Okay, At this point, it wouldn't be an unreasonable next step to talk about the A sync and await key words and how they work with promises. But I want to go a little deeper and lay the groundwork for that discussion by first giving you an overview of a relatively new feature in JavaScript, known as Generators. I'll do that in the next clip
Understanding Generators

[Autogenerated] generators were added to the E S 2015 version of JavaScript and, along with promises, form the technical foundation for the A sinking await keywords will examine shortly. I think going into that presentation with a basic understanding of generators will be helpful. Though generator objects are produced by generator functions, they're a special type of function that could be paused in the middle of execution and resumed at some point in the future. This is very different from the normal function behavior you're probably used to in which a function runs to completion from top to bottom and only executes again if you call it again. As if pausing a function wasn't enough of a trick. Generator functions also store the state of the function while it's paused so that when it resumes, all of the variables have the same values, and it's as if it never stopped executing in the first place. Generator functions return generator objects. The most important thing to know about generator objects is that they're also IT aerators. That means they implement the IT Aerator Protocol, which means they have a method named next. You can call the next method over and over until the object reports it doesn't have any more values. This is really what happens under the hood when you use the for each loop to iterated over a collection of some sort. In the case of generators calling next is what restarts a pause generator function. I'll show you some examples in just a minute. Another important thing to point out about generator functions is that they employ a technique known as lazy execution. This really just means that values error computed on demand. If a function is paused, it's not doing any work until you explicitly resume it. The benefit here is that it's not doing any unnecessary work. Let's hop into a very quick demo so you can see the syntax for generator functions and what the new behavior actually looks like. I'm not going to work with the demo app code directly in this demo because I want to keep this a simple is possible and just demonstrate how you can pause code execution with a generator function. Even though I'm not going to modify the existing demo code, I am going to do this demo in the project just so the generator code. I'm going to show you stays with the rest of the project, and you don't have to do anything extra to download it. I've got my visual studio code terminal open to the right side of the window now, just to make it a little easier to show you what's happening. As I run the code, I'll start by adding a new file to the root of the project. I'm just going to name it generator function dot Js right at the top of the file. I'm going to write a new generator function. There are a couple of new bits of Syntex I'll point out along the way. The first is that generator functions include an asterisk between the function, key word and the name of the function. It doesn't matter where you put the asterisk. It can appear right after the function keyword with no space in between or, as I have it here just before the name of the function. Both are valid, but I think I see them written this way more often. I've named my function generator function, and other than the asterisk, it really looks like any other function. The first line of code I'll add to the function is a log statement reporting that the function is actually running. Below that, I'll declare a variable named X and assignment the value. Five. I'm then going to use a special JavaScript keyword to Paul's execution of the function. The yield keyword will return the value after the keyword and then pause the function until I explicitly resume it. Since I'm yielding the value of X here, and I know that X is five. At this point, the value five will be passed back to the calling code. Below this, I'll increments X and then return its new value. Let's now call this function and observe how it behaves. Since generator functions return generator objects that implement the IT aerator protocol, I'll call the function and assigned the return value to a variable named IT aerator. I'll then just add a log statement reporting that the code is all done. I'll run the code in this file over here in my console window by typing the command node space generator function dot Js Notice that the only output I get is the all done message. I called the generator function, but I don't see the message I logged at the beginning of it. The reason for this is another of the differences between generator functions and regular functions. When you call a generator function, your returned an iterated er in the body of the function won't actually begin to executable. Call the next method. On that IT aerator. I'll add a new line of code here. To do that, I'll call the next method on the IT aerator object and passage Return value to console DOM blog. I'll now run the program again in the terminal. This time I get more output. I first see the log statement I included at the beginning of the generator function. Below that, I see the value returned by the call to next. It's actually an object that has a value property and a done property. Any object that implements the IT Aerator Protocol returns an object with this structure when you call the objects next method. So what happened here is that I called next on the IT aerator, and the first line inside the function logged a message. The variable was declared and a sign of value, and then we hit the yield expression. Since we're yielding the value of X and Object was returned that had the value property set to five. Since we're not at the end of the function yet, the done property was set to falsy. At this point, the function is paused and will only be resumed with another call to the next method. I'll copy and paste Line 13 so that I now have two calls to the next method and then run the code again. The first two lines in the output this time look just like they did before. However, when I called next a second time, the function resumed executing online five it then Incremental X and returned the new value. The object log shows that the value is now six and the done property is true. The done property was set to true because the new value was passed back with return instead of yield. So the caller knows the function has done executing. It's also possible to pass values into a pause generator function. I'll add a new line after I increments X. It will again yield X, but assign the value to a new variable Wi-Fi the value that gets assigned to why here will be whatever I pass to the next method to resume execution. I'll change the return statement to return the sum of X and Y and then add another call to the next method below and pass it the value. Four. I'll now run the code one more time. This time, the second call to next causes the code to run to the yield expression online eight that returns the second object in the output with the value six and done set defaults. It's important to note that the function is pause before the assignment to why has taken place. When I call next a third time, the function resumes online. Eight, and the value I pass to next will be assigned to Wi-Fi. At this point, the value of X is six, and the value of why will be four. The following line returns the some of those, which is how we get the last object in the output. Reporting the value is 10 and done is true. This also demonstrates the lazy evaluation I mentioned earlier. The calculation online nine didn't happen until I explicitly called next a third time. Only then was the additional work done. There's much more two generators than what I've shown you here. But they're not a language feature you're likely to use directly on a daily basis. However, the ability to pause a function and resume it at a later time is what enables these a sinking await keywords will look at next.
Writing Cleaner Code with async/await

[Autogenerated] Now that you have a high level understanding of how generators work, it's finally time to take a look at the A sync and await keywords. As I've already mentioned, they're built on top of promises and generators the A saint keyword marks of function as one that can be paused while it awaits the resolution of a promise. I'll show you the syntax in just a second, but one of the advantages of using a sync in a weight is that it lets you write a synchronous code that reads more like synchronous code. It reads more top to bottom without you having to mentally follow the path of a callback or a handler. Method registered with the promise promises error still being used, though the data you return from a sync function is automatically wrapped in a promise and the calling code comprise a cess that promise using the methods I showed you earlier in this module, applying the await keyword to a function that returns a promise will pause the function while it waits for the promise to be resolved. Once it is resolved, the data will automatically be unwrapped from the promise and assigned to a variable. Let's take a look at the Syntex to do this. Earlier, I showed you how to process and return a promise with code similar to this. Here I've got a function named get data that will return a promise inside it. I'm calling another function that also returns a promise. And I'm using the then method on that promise to parse the JSON returned. The then method will wrap the parse data into a new promise that will be returned from the get data function. Let's now see how it can rewrite this code. Using a sync away here, I've still got a function named Get data. However, in front of the function declaration, I've added the A sync keyword this effectively, Let's any code that calls this function know that it will execute a synchronously and return a promise inside it. I'm still calling another method that returns a promise. But rather than chaining on a call to the then method and registering a function to parse the JSON returned here, I've just added the await keyword in front of the function call similar to the yield expression I showed you in the generator demo. The await keyword will pause this function while it waits for the promise to be resolved. Since we know this method returns a promise you might expect that promise to be assigned to the raw data variable, However, the awake keyword does a little extra work for us. You can only use it in front of a function that returns a promise, and it will automatically unwrap the data in the resolve promise. And that's what will get assigned to the raw data variable. I then take that raw data, pass it to the JSON parse method and return the object. It returns, however, even though it looks like this will return the parse data object. Because this function is declared with E. A sync keyword, the data object will automatically be wrapped in a promise, and the promise is what will be returned to the caller. The code that calls this a sync function will then process that promise just like any other promise, using the then and catch methods you've already seen. Let's now go back to the demo app and update the promise code I wrote earlier to use a sync and await
Utilizing async/await

[Autogenerated] Let's now take the next step in the evolution of the asynchronous code I've been writing in the course and updated to use these a sync and await keywords. Before I open the code back up, I want to show you a new node function I'm going to use to read the data file in this demo. So far I've been using the F S module and using methods that take callbacks as parameters. However, there's also an API inside the FS module that returns promises. I'm here on the documentation page for the version of note I'm using. I'll scroll down just a little and then click on the link for the file system module. On this page, I'll scroll down a bit, and here you can see the section for the F S promises. API. I want to read the data file using this API, so I'll scroll down a bit inside this section and then click the link for the read file method. You can see that it's pretty similar to the function I've been using. It takes a path to the file and some options, but instead of passing it a call back, it returns a promise. I'm going to update the code in the demo app to use this version. In order to use it, I need to add a new import at the top of my code file. I've already got F s, so I'll call this one. FS promises and require F s dot promises. I'll kneel, scroll down to the get clothing data function and make some changes. I want to make sure this promise code I've already got stays in the download materials for you, so I'm just going to comment all of it out rather than delete it. I'll now add some new code. I'll first call the read file function. I just showed you that returns a promise. I'll chain on a call to then to parse the data into an object. The result will be wrapped in a new promise. I'll capture that promise in a variable, and then I'm going to log it to the console. I want to do this to show you how it compares to logging the data. I'll await from a promise in just a minute. Leslie, I'll return it to the color. Remember that the get method above is already coated to process the promise and return the clothing data to the browser. So this should still deliver the correct data to the browser. Let's try it out. I'll go back to the browser and refresh the page. I do, in fact, still get the data I expected back in my editor. I'll open the terminal and take a look at the output that was generated. Noticed that my log statement did try to log the actual promise object. I don't see any actual data, and the status of the promise at that time was pending, meaning it hadn't yet been resolved. Let's now update the code to a sync await rather than capture the promise. Return from the reed file function. I'm going to add the await keyword in front of it. This is valid because the function returns a promise I can only await code that returns a promise. I'm going to assign the result of this statement to a new variable named raw data. I still want to parse the data, but I no longer need to pass a function to the then method to do it. I'll store the parsed object in the clothing data Barria ble just to confirm we're no longer dealing with a promise at this point in the code. I'm going to change this log statement to log the clothing data object instead of the earlier promise. I'll also return the data instead of the promise. You can only use the await keyword inside functions declared with E a sync keyword. So the last thing I need to do is add that at the beginning of my function declaration. Okay, let's now run it again. I'll refresh the page and then go back to the editor and look at the output in the terminal. This time it was the actual data that got logged, not the promise object. This is the same data I returned from the A sync function. But remember that I didn't change anything about the calling code. It's still written to process a promise. This all worked because functions declared is a sync, automatically wrapped returned data in a promise and return the promise to the collar because it actually returns a promise. I could also await it in the calling code that's going to look just a little bit different. So let me show it to you real quick. I'll scroll back up to the get method that calls get clothing data all again come in out all of this existing code so it stays in the course downloads. For your reference, I'll leave the last log statement online. 19. Remember, I can only await a promise inside and a sync function. This is an anonymous callback function, but I can still add the A sync keyword in front of it in the body. I'll await a call to get clothing data and assign the result to a variable named data just to help us follow the flow of the execution. I'll add a log statement that I'm about to return the A sync data to the browser. I'll then call the Sindh method on the response object to return it. One thing you may have noticed about this way of processing promises is that I haven't shown you an equivalent to the catch method that can handle errors. The await keyword only handles the successful resolution of the promise in order to catch any errors that error thrown. We need to wrap the call on a try catch block. I'll catch any errors that error thrown and just return a 500 status code to the client like you saw me do earlier. I think I'll test the error case first. This time, I'll again change the name of the data file, does something that doesn't exist and go back to the browser. I'll open the developer tools to the network tab and then refresh the page. As expected. I don't get any data, and if I scroll up just a bit, you can see the request for the clothing data returned to 500 server error. I'll go change the name back to clothing JSON and try it one more time. Much better. I again have data on the screen, but let's go look at the output in the terminal. The thing I want to point out here is that are doing more work log messages. No longer the first thing being logged, it's the last. The reason for that is the function passed to the get method is now being paused online. 12. While it awaits the resolution of the promise instead of continuing to executable some asynchronous code runs elsewhere, it is the asynchronous code. Since I'm not actually doing any useful work later in this method, I'll just leave it as is and delete the log statement at the end. The a sync and await keywords error the newest tools for working with asynchronous code in JavaScript. If you haven't encountered them out in the world yet, you surely will soon. I personally think they make your code more readable, but you may decide you prefer using promises directly, and there's nothing wrong with that. We looked at both techniques in this module, and you've seen how they each enable you to do the same work you might have previously done with callbacks. In the next module, we're going to shift gears a little bit and look at writing event driven asynchronous code with event emitters.
Writing Event-driven Code with EventEmitters
The Importance of Event-driven Code in Node.js

[Autogenerated] so far in this course, I've mainly focused on the syntax for writing a synchronous code in node. In this module, we're going to look at control flow of a slightly different sort, and I'll show you how to write event driven code using event um, eaters. Event driven programming basically describes a style of programming in which the flow of your program is, at least in part, determined by the events that occur as the program executes. These can do be events somewhat external to your programs, such as a user clicking a button in the app or they could be internal events, such as a notification that a new connection to a server has been made. I think most people associate event driven programming with graphical user interfaces, common events, error, things like clicking a button, moving a mouse and selecting a menu item. However, this style of programming is not limited to clients IT code. In fact, it's used heavily in nodemon, right on the about page of the node website. We're told that as an asynchronous event driven runtime, Node.js is designed to build scalable network applications. The built in a venom inter classes. What makes event driven code. Possible in node is what allows you to easily register functions that will execute in response to events, as well as create your own classes that emit events. Other code can do respond to many nodemon a jewels. Use event emitters to emit events you can handle. Browsing through the official documentation reveals lots of events included, with many popular built in modules that you can handle and respond to in your own code. The file system HTTP and Net modules I'm cooking through Here are just a few of the examples of modules that expose events you can use in this course module. I'm going to show you how you can handle omitted events, but also how you can extend the event a middle class and emit events in your own code.
Understanding EventEmitters

[Autogenerated] There are a bunch of methods available on event emitter objects, but most of them exist to support the two primary functions of event emitters emitting events and responding to events. That's the functionality I'm going to focus on in this module. Let's imagine I want to admit a new event when some new data is received in my app events. Error given names that error just strings. You can name them whatever you like. Well, imagine I name this one data I can register code to execute that event is emitted by calling a method on the event emitter named on. I'll show you the exact syntax in a minute, but the idea is that you can write code that says on the occurrence of the data event one This function process data. In this case, one nice thing about event emitters is that you can wire Oppa's many listeners for a particular event, as you'd like, and they can eat respond to the event with their own function, appropriate to the task they need to accomplish. This second handler will respond to the same data event by executing the log data function, and I might also have a third listener that executes still a different function. When the event is emitted, all three listeners will be notified and they're registered. Functions will be executed. Let's now look at the actual syntax required to use of in emitters. The first thing you need to do is include the Events module. At this point, you really have a couple of options. Event emitter is a class you can extend if you want to create a custom class that includes everything you need to support events. However, if all you need is the ability to emit and handle events, you can use the event a middle class directly and just create a new instance of it like you would any other class. Once you have an instance, you register an event listener by calling the on method and passing it the name of the event you want to listen for and the function that should execute The event is emitted here. I'm listening for the wrote code event, and when it's emitted, I'll execute an arrow function that just logs the message. Somebody wrote some code, as I showed you on the last slide. You can also register more than one listener this one will listen for the same event, but log a slightly different message to the console. I omit these event by calling the emit method on the event emitter instance and passing it the name of the event. Remember that event names error, just strings, and you can name them whatever makes sense for your app. When the road code event is emitted, I'll get these two messages in the console as the two listeners execute the functions I registered. It's also possible to pass parameters to event listeners here. I'm listening for the same wrote code event, but notice that the arrow function I registered to handle it accepts one parameter. I've named language. The value for that parameter is specified when the event is emitted. You pass any parameters after the name of the event. When you call the emit method on the event emitter, I'm passing JavaScript here so the output from the listener will look like this. Let's now go back to the demo app and add a new feature to it that uses event emitters
Creating and Using an EventEmitter

[Autogenerated] I'm now going to use an event emitter in the demo app to create and respond to changes in the application data. I've added some new code to the apps since the last module, so I want to take just a minute to show you the new bits. I've added a new link at the end of the clothing item list that goes to a new page where I can add new items. This simple form could be the beginning of a new admin page for adding new products to the carved rock database I can type in a new item name like boots at a price, and then click the add item button. Doing that sends an HTTP post request with the new data to the node server app. We've been working on the server, writes the new data to the clothing dot JSON file and then returns it to the client. You can see here that boots now appears at the bottom of the list. Let me now quickly show you the code I wrote to do this inside the clothing dot Js file we've been working in throughout the course. I've added a new post method to the clothing router to handle the post requests sent from the client code. I've written it using the techniques I showed you in the last module. It's Paston, a sync callback function. I read the existing clothing from the clothing dot JSON file and await the promise return. Just like you've already seen me. Do I Then call a new function that will calculate the next available IDE value I can use for the new clothing item. I create the new item and assign it the new IDE and the item name and price that were passed in as part of the HTTP request body. I then pushed the new item onto the array of existing data and call another function that writes the array back out to the clothing dot JSON file again. This is not how you would want to store data in a production app, but it meets our modest demo needs. Once the data has been saved, I returned and HTTP 201 status back to the browser, along with the new item that was saved. Toward the end of the file, you can see the two new functions I wrote to calculate the next IDE and save the clothing data. Perhaps the only interesting bit here is that I'm using a function from the F S promises API to ride out the file. I'm returning the promise it returns, which is why I was able to await the call to the function in the code above. Okay, I now want to add a new feature to the server side code that will listen for changes being made to the data and take some action when they're detected. Obviously, this all starts with a new of intimate er. I'm going to create that in a new file inside the server directory named data monitor dot Js. As I showed you earlier, the first thing I need to do is require the built in events module. You can use the event, um, inter class directly, but it's also possible to extend it. I'll do that here by creating a new class named data monitor and just specify that it extends even emitter. That's really all there is to creating a class to do whatever you need and emit and handle events. I'm not going to spend a lot of time adding a bunch of custom code to this class now, but I will quickly give it a public field named Log Level, which I'll just set to Dev. I'll then export the class from the module to use the new class. I'll go back to the clothing dot Js file and require it at the top of the file. Right below that, I'll create a new instance of the class and assign it to a variable named data monitor. I want to use these e event emitting capabilities of the class to notify listeners when new data has been added. The listeners com'on take whatever action is appropriate for that event. I'll add the code to emit these event down here inside the post method. I'll add it just before I send the response to the client. I just called the emit method on my data monitor. Since it extends these event a middle class, I'll name the event. Data added. Remember that I can include additional parameters to the emit method that will then be passed to the handler functions. Listening for the event, I'm going to pass him the name of the clothing item that was at it. I now need to add some code to listen for the event. I'll do that Back near the top of the file. We add event handlers by calling the on method of the event emitter. The first parameter passed to it is the name of the event. Mine is, Data added. You then pass it. The function that should execute the event is omitted. I'm going to use an arrow function. It will be passed, the name of the data item added, and I'll just log the name of the item to the console. That's all I need for a basic implementation of my data monitor. Let's try it out. I'll go back to my browser and add another new item. I'll add a hat this time and make it $10. I'll click Add item and the request is sent to the server and were redirected to the clothing list page. And you can see hat does appear here in the bottom. Back in V s code. I'll open the terminal and check the output. There. It looks like it worked as expected. You can see here the log message output by the event handler reporting that a new data item was at it. You may also notice that nodemon restarted my server after the log message. That's just because the new item was written to the clothing dot JSON file, which nodemon saw was a change and helpfully decided to restart the server for us. We can safely ignore that. Let's now make this a little more interesting and add a second event listener for the data added event. I want to be able to monitor data all over my apps. So I think it would be better to instantiate my data monitor in my server dot Js file and pass it around wherever I want to use it. Since I want to be able to, pass it into this file when it's required. I'll update theme module .NET exports line at the bottom and a sign of a function instead of the express router. That function will be passed the data monitor, which I'll assigned to a variable and then return the router. This is just a bit of a trick that lets me pass an object into this module and still return the same thing it did before. I'm now going to cut all the code in this file and pasted inside this new function. Okay, I need to make to more small changes in this file, I no longer need to instantiate a new data monitor, since an instance will now be passed into the module. I also don't need to require the data monitor class at the top of the file. I'll now open server dot Js and make some changes there. I'll now instantiate the data monitor in this file, so I'll add the necessary require statement at the top of the file. I'll create the new instance right below that I'll then go ahead and add another event listener for the data added event. This time, I'll ignore any parameter passed with the event and just logged that new data was added in order to use the same data monitor instance in the clothing module, I'll pass it as a parameter. When I require that module, it will be received by the function I added to the module .NET exports just a moment ago. So now what we have is a data monitor instance that should emit an event when a new clothing item is added and hopefully we'll see it handled by two different listeners. The one I just added here in server dot Js and the one we already had over in clothing dot Js Let's go back to the browser and try it out. This time I'll add a coat for $50. I'll click add item and you can see it does get added to the end of the list Back in Via is code all again opened the terminal. As expected, you can see the log messages from both event listeners here. It all seems to be working fine. However, what may not be apparent from this demo is that the event listeners error actually executing synchronously when the event is omitted. In the next demo, I'll talk a little more about that and show you how to configure them for asynchronous execution.
Configuring Event Handlers for Asynchronous Execution

[Autogenerated] the event handlers I can figured in the previous demo are currently executing synchronously. In this demo, I'll show you how to configure them for asynchronous execution, if that's what you determine you need in your app. Event emitters automatically called their event listeners synchronously in the order they were registered in order to quickly demonstrate that I'll add a new log statement just after I admit the data added Event online 44. I'll just log that. I'm returning a new item to the browser and we'll see where this executable to the log statements inside the event listener functions. Remember from the previous demo that I currently have two listeners registered for this event. The first one gets added in server dot Js as soon as the server starts and the second gets added when the clothing dot Js file is required from server dot Js, Let's go out a new item in the browser and see how this now behaves. This time I'll add a pair of gloves for $5. I'll click Add item and we can. See it did get saved and added to the end of the list. Back in ves code, I'll open the terminal notice the order of the log statements here, you can see that both event listener functions were executed before the log statement that appeared right after the line of code that omitted the event they also executed in the order they were added. This first one is the output from the listener in server dot Js, and the next one that includes these e item name was added later in clothing dot Js. The no documentation clearly explains that listeners error called synchronously in the order they were registered and goes on to say that this insurers proper sequencing of events and helps avoid race conditions and logic errors, those error good things and good reasons to build it the way they did. However, they also acknowledged that there may be times when you want to have a specific listener execute a synchronously for one reason or another. The recommended way to do that is to wrap the body of the listener function in a call to the set immediate function. I'll do that to the listener. I have registered here at the top of the file. The body of the function is just one line and I'll wrap the whole thing inside a call to the built in set immediate function. This essentially pushes the execution of this code into the next cycle of the event loop. Let's go at another new item and see how the behavior changes. I'll add a $10 scarf this time. My list is getting long, but you can see it did get added to the end. I'll now go check the output in the terminal. Notice that this time the output from the listener I forced to execute a synchronously appears after the log statement announcing a new item is being returned to the browser. The listener was still called in the same order, but the call to set immediate caused the body of the function to execute on the next interational the event loop. Keep that handy trick in mind in case you find yourself preferring that a handler function executable notice built on an event driven architectures. The event. A middle class enables you to respond to events emitted in many built in modules as well as, um, it your own events by either using the event a middle class directly or extending it in one of your own custom classes in this module you've seen how to use these event emitters emit method to a mid events and the on method to listen for those events. I think they provide a very clean API that lets you easily take advantage of the event loops ability to process new events with each iteration of the loop. This allows you to decentralize control flow for your app and right code to respond to events as they happen. Coming up in the next module, I'll show you how worker threads enable you to effectively use multiple event loops to truly run code in parallel.
Utilizing Worker Threads
Understanding Worker Threads

[Autogenerated] worker threads error a relatively new addition to nodemon but one that gives you a straightforward API to deal with CPU intensive task while still maintaining a responsive application. The note Event loop is great, it letting you a synchronously offload io operations. But the single threaded nature of the event loop means that there's not a great way to deal with long running CPU intensive task until recently. Worker threads give you a way to send those types of workloads to another thread while keeping your main thread available for new user request worker threads in note error Very similar to web workers that error available on browsers. The problems they solve are the same, and the APIs error similar. But there are some differences just due to the different runtime environments. Each worker thread instance is really a new instance of the event loop. You can think of the event loop we've been working with so far in this course is running on the main threat of the application. The application receives a request to do some work, and the event Luke picks it up and takes care of it. Creating a new worker thread effectively gives you another event loop. The benefit of this is that running a CPU bound task here leaves your event loop on the main thread free to continue handling user request. If you've done multi threaded programming in other environments, you may be surprised to find that you don't have some of the traditional mechanisms available for thread synchronization, however you are able to pass messages back and forth between the main threat and the worker thread. Also, creating a new worker is as easy as calling the worker constructor, So if you determine you need more than one, you could easily create as many as you need. Speaking of creating workers, let's look at the syntax to do that now. In order to use worker threads, the first thing you need to do is require the worker threads module here. I'm just pulling in the worker class, but I'll show you other parts of the module as we go along. Probably the easiest way to create a worker is also the recommended approach for use in production apps. You just instantiate a new instance of the worker class and passed to the constructor a JavaScript file containing the code. The workers should execute, the worker will immediately begin executing the code inside the file on a different thread from the one running the main note event loop. A second option you have for creating a worker is to pass the code you wanted to execute directly inside the constructor. As a string literal, this would get pretty messy, with more than a few lines of code. But should you choose to use this technique, you also need to pass an options object as the second parameter to the constructor that has these evil property set to true. That will let nodemon Oh, that it should interpret the first parameter as the actual code to execute. There's a third option that lets you use the code in the same file without passing it all to the constructor. Here I put in the is main thread property. In addition to the worker class. If you references main thread and it returns true, then you know you're running on the main thread. If it returns falsy, then you know you're running on a worker thread. Therefore, you can check to see if you're on the main thread before instantiate ing a new worker and passing it underscore underscore file name as the file to execute that will create a new worker that also executes the code. In this file, however, is main thread will return falsy for it, so you just include the worker thread code inside the else block. In the next couple of demos, I'll create a worker thread and show you how it allows the main threat to remain responsive and how you can communicate between the main and worker threads.
Creating and Receiving Messages from Worker Threads

[Autogenerated] Let's now take a look at how a worker thread can take the pressure off the main thread and keep your apps responsive. I'll also show you how to pass messages from the worker thread back to the main thread in order to keep the code simple and focused on the details of worker threads. I'm just going to keep all of the code in one file and focus on giving you an overview of the API and the functionality it enables. I'll start by adding a new file to my project named Threads Node.js. I'll then paste in a short little function that will simulate work that blocks the event loop. I've named it Waste Time, and instead of doing any useful work, it will just loop for the specified number of milliseconds that effectively blocks the event loop and keeps any other code from executing. During that time above the function, I'll paste in some code to exercise it online's one and nine. I've got a couple of log statements that just remind us the code is executing on the main thread between them. I logged that the code is getting started and then I call the waste time function and have it blocked for two seconds. It then reports the code is in the middle before blocking for another two seconds and finally reporting that it's all done before adding a worker thread. Let's run this in the terminal and observe how it behaves. I'll start it with the command node space threads dot Js. It does what I hope you would expect at this point in the course. It reports that it's running on the main thread, and then we get the other log messages with the delays based in between. We don't get the last log message until the very end, because none of this code was a synchronous, and it's all running on the same threat. Let's kneel. Modify this to have a worker thread executable the blocking code. The first thing I'm going to do is require some things we need from the worker threads module. I'll include the worker class, the is main thread property I showed you earlier, and parent port, which I'll explain shortly. I'm going to keep the main thread code and the worker thread code all here in this file, so I'll use the is main thread property and if else blocks to keep the two separate, the If block will contain the code executed by the main thread. And I'll initially move all but the waste time function. Insight it. The code in the else block will execute the worker thread code. Saul, Move all of the blocking code. Insight it. Okay, I now need to actually create the worker thread. I'll do that by calling the worker constructor since they wanted to execute the code. In this file, I'll pass underscore underscore file name to it. As a parameter, the worker thread will begin executing the code as soon as it's instantiate it. Notice that I created it between the two console dot log lines, reporting that this is the main threat. Before I run this, I want to make another change to show you how the worker thread can communicate back to the main threat. To do that, I'm going to use the parent port I imported at the top of the file. Rather than log messages to the console in the worker thread, I'm going to send those messages from the worker back to the main thread to handle Is it pleases I can do that by replacing console dot log with a call to parent port dot post Message Parent Port is a communication port back to the main thread. It's also an event emitter, which I covered in the last module. Whatever I passed to Post Message will be passed as a message event to the main threat. I'll copy and Paste parent port dot post message over the other two console DOM blog statements and then go at an event handler to the main thread code. The event will be emitted on the worker instantiate. Remember that you can register event handlers by calling the on function and pass it the name of an event and a function that should execute the event is omitted. The name of the event sent across the parent port is message, all right. A handler function that just takes the string it receives and logs it to the console. That string will be whatever was passed to the post message calls below how prefix the output with the word worker. So we know it was a message received from the worker and logged inside the main threat. Okay, let's now run it and see how it behaves. You can see right away that the main event loop was not blocked This time. We immediately got the output from the to log statements at the beginning and end of the main thread. Remember, I created the worker thread between them. The message is passed back from the worker got handled and logged later, the waste time function was still blocking an event loop. But this time it was blocking the Workers Event loop, which left the main event loop free to continue processing user request. You just saw how to pass messages from the worker thread to the main thread. In the next demo, I'll show you how to pass data and messages from the main thread to the worker.
Sending Data and Messages to Worker Threads

[Autogenerated] you've seen how to pass messages from the worker thread back to the main thread. So let's now take a look at how to send data and messages from the main threat to the worker. Passing simple messages from the main threat to the worker isn't really much different than passing them from the worker to the parents. You still call a method named post Message, but you call it on the worker instantiate rather than the parent port object. Here. I'm sending a string message to the worker to let it know the main threat is done with its work. I'm sending it a string, but I could pass it just about anything. An object with lots of properties is perfectly valid. I'll handle this message at the very beginning of the worker thread code by listening for a message event on the parent port. I'm just going to logged the message with a prefix of parents, so we know it was sent from the parents. I'll now run it in the V s code terminal with the command node space threads dot Js. The first part of the output looks just like what we saw in the last demo. However, the last line here does confirm that I did successfully pass a message from the main thread to the worker. One thing to note, though, is that this was the very last line output to the console, even though I registered the handler at the very beginning of the worker thread code. The reason the message was processed at the end was because the Workers Event loop is still being blocked by the calls to the waste time function. It wasn't free to handle the message from the main thread until after that code was done. Passing messages like this is very handy, but you may find that when you create a new worker thread, you want to pass, um, initial data to it that it can use right away. You can do this with a special value passed to the worker constructor named Worker Data to use it. I need to include worker data Among the list of things I'm importing from the worker threads module I can. Then use it to pass data to the worker by passing an options object to the worker constructor. I'll use an object literal and give it one property named worker data. The value for that property could be whatever I want. I'm going to assign it an object, which gives me the flexibility to give it properties for any data values I want to pass to the worker. I'll give it a property named Output prefix I can, using the handler function that logs messages from the main threat, I will sign it the value received message. I'll give it another property named Time to Waste, which I'll use to pass in the number of milliseconds. I want to block the event loop with each call to the waste time function. I'll set it to 500. Using these values in the worker thread just requires referencing them on the worker data object. Instead of pre fixing the message from the main thread with the word parent, I'll change this template string to use worker data dot output prefix instead. Similarly, I'll update the two calls to the waste time function to use the time to waste value on worker data instead of the hard coded 2000 I've been using. I'll go back to the terminal and run the code one final time. You can see it using the shorter time to waste value because it runs much faster. Now you can also see the new prefix was used when out putting messages from the main threat. Passing messages error. Great. But definitely keep the worker data object in mind If you need to initializer your worker threads with some data when they're instantiate id worker threads error. A great new feature in nodemon. Keep in mind that there really only meant to be used for CPU intensive task for i o bound code like disk access and network calls, its more efficient to use these asynchronous APIs that have been in nodemon yours. Okay, that brings us to the end of this module and the end of the course. I hope you've enjoyed it. And I also hope you'll take a minute to rate it and leave me some feedback on the course discussion board. As always. Thanks for watching and good luck on your next node. A jinked
Course author
Author: Brice Wilson
Brice Wilson

Brice Wilson has been a professional developer for over 20 years and has used many tools and programming languages during that time. His current interests are centered on web services, single-page...
Course info
Level
Intermediate
Rating
4.875 stars with 96 raters(96)
My rating
null stars
Duration
1h 26m
Released
28 Feb 2020
